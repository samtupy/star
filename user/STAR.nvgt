#include "form.nvgt"
#include "ini.nvgt"
#pragma asset audio
#pragma asset "STAR.ini"

atomic_bool program_exit = false, server_connected = true; // Initial loop will set server_connected to false when needed.
class message_queue {
	json_object@[] message_queue;
	fast_mutex message_queue_mutex;
	void enqueue_message(json_object@ msg) {
		fast_mutex_lock scoped(message_queue_mutex);
		message_queue.insert_last(msg);
	}
	json_object@ dequeue_message() {
		fast_mutex_lock scoped(message_queue_mutex);
		if (message_queue.length() < 1) return null;
		json_object@ r = message_queue[0];
		message_queue.remove_at(0);
		return r;
	}
}
message_queue recv_queue;
message_queue send_queue;

web_socket@ ws;
void socket_thread() {
	json_object parse_fail;
	parse_fail["error"] = "received invalid message from server";
	json_object lost_server;
	lost_server["error"] = "lost server connection...";
	while (program_exit == false) {
		try {
			http_client cl(config.get_string("", "host", "127.0.0.1"), config.get_double("", "port", 7774));
			http_request req(HTTP_GET, "/");
			http_response resp;
			@ws = web_socket(cl, req, resp);
			int flags;
			ws.send_frame("""{"user": 1}""");
			server_connected = true;
			recv_queue.enqueue_message(json_object());
			while(program_exit == false) {
				json_object@ msg_to_send = null;
				while ((@msg_to_send = send_queue.dequeue_message()) != null) {
					ws.send_frame(msg_to_send.stringify());
				}
				if (ws.poll(timespan(5000), SOCKET_SELECT_READ)) {
					string frame = ws.receive_frame(flags);
					if ((flags & WS_FRAME_OP_BITMASK) == WS_FRAME_OP_CLOSE or flags == 0) {
						ws.shutdown();
						break;
					} else if ((flags & WS_FRAME_OP_BITMASK) == WS_FRAME_OP_PING) {
						ws.send_frame(frame, WS_FRAME_FLAG_FIN | WS_FRAME_OP_PONG);
						continue;
					}
					json_object@ o;
					try {
						@o = parse_json(frame);
					} catch { recv_queue.enqueue_message(parse_fail); }	
					recv_queue.enqueue_message(o);
				}
			}
		} catch {
			lost_server["error"] = get_exception_info();
			if (server_connected == true) recv_queue.enqueue_message(lost_server);
			server_connected = false;
		}
	}
}

void send_request(const string&in text, bool rendering) {
	json_object result;
	result["id"] = rendering? render_ID : string_hash_sha256(text, false);
	result["user"] = 1;
	string[]@ raw_lines = text.split("\r\n", false);
	if (rendering) {
		item_count = raw_lines.length();
		form.set_caption(f_render, "Cancel");
		play("begin");
	}
	json_array lines;
	for (uint i = 0; i < raw_lines.length(); i++) lines.add(raw_lines[i]);
	result["request"] = lines;
	send_queue.enqueue_message(result);
}
void starspeak(const string&in text) {
	if (text.empty()) {
		demo.close();
		return;
	}
	string data = string_hash_sha256(text);
	last_demoed_line = data;
	if (demo_cache.exists(data)) {
		data = string(demo_cache[data]);
		demo.close();
		demo.push_memory(data, true);
		demo.play();
	} else send_request(text, false);
}

audio_form form;
sound demo;
dictionary demo_cache;
string last_demoed_line;
ini config("STAR.ini");
int render_count = 0, item_count = 0;
int f_voices, f_quickspeak, f_script, f_render, f_exit;
int render_ID = 0x7fff;
void setup_interface() {
	show_window("STAR client");
	wait(100);
	form.create_window();
	f_voices = form.create_list("available &voices");
	f_quickspeak = form.create_input_box("&quickspeak", multiline:true, multiline_enter:false);
	f_script = form.create_input_box("enter &script", multiline:true);
	f_render = form.create_button("&render to wav");
	f_exit = form.create_button("e&xit", false, true);
	form.focus(f_script);
}

void main() {
	async<void>(socket_thread);
	speak("connecting...");
	while (true) {
		wait(5);
		json_object@ result = recv_queue.dequeue_message();
		if (@result != null and result.exists("error")) {
			int keep_going = question("STAR client error", "Coagulator at " + config.get_string("", "host", "127.0.0.1") + " does not appear to be online or your internet is broken. " + string(result["error"]) + " Run until connection is established?");
			if (keep_going == 2) {
				program_exit = true;
				return;
			} else break;
		} else if (@result != null and result.size() == 0) break;
	}
	setup_interface();
	while(!form.is_pressed(f_exit)) {
		wait(5);
		if (form.get_current_focus() == f_script and (keyboard_modifiers & KEYMOD_CTRL) != 0) {
			int dir = -100;
			if (key_pressed(KEY_UP)) dir = -1;
			else if (key_pressed(KEY_DOWN)) dir = 1;
			else if(key_pressed(KEY_SPACE)) {
				get_characters();
				dir = 0;
			}
			key_repeating(KEY_UP) or key_repeating(KEY_DOWN);
			if (key_repeating(KEY_SPACE)) get_characters();
			if (dir != -100 and form.set_line(f_script, form.get_line_number(f_script) + dir)) {
				const string text = form.get_text_reference(f_script);
				int line_start = form.get_text_cursor(f_script);
				int line_end;
				for(line_end = line_start; line_end < text.length() and text[line_end] != "\n"; line_end++);
				string line_text = text.substr(line_start, line_end -line_start);
				starspeak(line_text);
			}
		}
		if (form.get_current_focus() == f_voices) {
			if (keyboard_modifiers & KEYMOD_CTRL > 0 && key_pressed(KEY_C)) {
				clipboard_set_text(form.get_list_item(f_voices, form.get_list_position(f_voices)));
				speak("Copied");
			}
			if (key_pressed(KEY_SPACE)) starspeak(form.get_list_item(f_voices, form.get_list_position(f_voices)) + ": Hello there, my name is " + form.get_list_item(f_voices, form.get_list_position(f_voices)));
		}
		if (form.get_current_focus() == f_quickspeak and keyboard_modifiers & KEYMOD_CTRL == 0 and keyboard_modifiers & KEYMOD_SHIFT == 0) {
			if (key_pressed(KEY_RETURN)) {
				string text = form.get_text(f_quickspeak);
				int voice = form.get_list_position(f_voices);
				if (!text.empty() and voice > -1) starspeak(form.get_list_item(f_voices, voice) + ": " + text);
				else speak("Select a voice, type text and press enter to speak it");
			}
		}
		form.monitor();
		if (form.is_pressed(f_render)) {
			if (render_count > 0) {
				speak("Rendering in progress, will add canceling ability soon");
				continue;
			}
			string text = form.get_text(f_script);
			send_request(text, true);
		}
		json_object@ msg = recv_queue.dequeue_message();
		if (@msg == null) continue;
		if (msg.exists("voices")) {
			play("ready");
			json_array@ v = msg["voices"];
			form.clear_list(f_voices);
			for (uint i = 0; i < v.length(); i++) form.add_list_item(f_voices, v[i]);
		} else if(msg.exists("speech")) {
			string[]@ id_parts = string(msg["speech"]).split("_");
			bool rendering = parse_int(id_parts[1]) == render_ID;
			if (rendering) {
				render_count++;
				if (render_count < item_count) play("progress", pitch = (float(render_count) / item_count * 100.0) + 60);
				else {
					play("complete");
					form.set_caption(f_render, "&Render to wav");
					item_count = render_count = 0;
				}
				if (!directory_exists("output")) directory_create("output");
				file_put_contents("output/" + id_parts[2] + ".wav", string_base64_decode(msg["data"]));
			} else {
				string data = string_base64_decode(msg["data"]);
				demo_cache.set(id_parts[1], data);
				demo.close();
				demo.push_memory(data, true);
				demo.play();
			}
		} else if (msg.exists("warning")) {
			play("warning");
			if (item_count > 0) render_count++;
			if (render_count == item_count and item_count > 0) {
				play("complete");
				form.set_caption(f_render, "&Render to wav");
				item_count = render_count = 0;
			}
			speak(msg["warning"], false);
		} else if (msg.exists("error")) {
			play("error");
			speak(msg["error"], false);
		}
	}
	program_exit = true;
}

sound@[] g_sounds;
enum sound_flags { SOUND_LOOPING, SOUND_PAUSED }
sound@ play(const string&in filename, int64 flags = 0, double pitch = 100) {
	sound s;
	if (!s.load("audio/" + filename + ".ogg")) return null;
	s.pitch = pitch;
	if (flags & SOUND_PAUSED == 0)
		flags & SOUND_LOOPING > 0? s.play_looped() : s.play();
	for (uint i = 0; i < g_sounds.length(); i++) {
		if (g_sounds[i].playing or g_sounds[i].paused) continue;
		g_sounds.remove_at(i);
		i--;
	}
	g_sounds.insert_last(s);
	return s;
}
